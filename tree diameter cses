question==>https://cses.fi/problemset/task/1131/
// Things to know very important 1- tree can be of any type there is nothing that serial wise tree will be there means if there are 10 nodes so node 5th can be last and node 10th can be first;
// Dont think that tree will be in serial manner
// intution behind this solution find the deepest node and calculate distance between deepest and rest of the nodes and select maximum of them;
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int m= 0;
int no=0;
int lca(int x, int y, int parent[][18], int level[])
{
    if(level[x]<level[y])
    {
        swap(x,y);
    }
    int dist = level[x]-level[y],i;
    for(i=0;i<=log2(dist);i++)
    {
        if(dist&(1<<i))
        {
            x = parent[x][i];
        }
    }
    if(x==y)
    {
        return x;
    }
    for(i=17;i>=0;i--)
    {
        if(parent[x][i]!=parent[y][i])
        {
            x = parent[x][i];
            y = parent[y][i];
        }
    }
    return parent[x][0];
}
void dfs(int node, int par, vector<int>adj[], int parent[][18], int level[], int lev)
{
    if(lev>m)
    {
        m=lev;
        no=node;
    }
    cout<<node<<lev<<no<<"\n";
    level[node]=lev;
    parent[node][0]=par;
    int i;
    for(i=0;i<17;i++)
    {
        if(parent[node][i]>=0)
        {
            parent[node][i+1]=parent[parent[node][i]][i];
        }
    }
    for(auto it: adj[node])
    {
        if(it!=par)
        {
            dfs(it,node,adj,parent,level,lev+1);
        }
    }
    return;
}
int main()
{
    int n,i,u,v;
    cin>>n;
    vector<int> adj[n+1];
    int parent[n+1][18]={0},maxi=0,level[n+1]={0};
    for(i=0;i<n-1;i++)
    {
        cin>>u>>v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    dfs(1,-1,adj,parent,level,1);
    for(i=1;i<=n;i++)
    {
        maxi = max(maxi,level[no]+level[i]-2*level[lca(no,i,parent,level)]);
    }
    cout<<maxi<<"\n";
    return 0;
}














optimesed solution======

#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int m= 0;
int no=0;
void dfs(int node, int par, vector<int>adj[], int lev)
{
    if(lev>m)
    {
        m=lev;
        no=node;
    }
    for(auto it: adj[node])
    {
        if(it!=par)
        {
            dfs(it,node,adj,lev+1);
        }
    }
    return;
}
int main()
{
    int n,i,u,v;
    cin>>n;
    vector<int> adj[n+1];
    for(i=0;i<n-1;i++)
    {
        cin>>u>>v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    dfs(1,-1,adj,1);//this funtion will find the deepest element 
    dfs(no,-1,adj,1);//this function will find the distance of every node from deepest node
    cout<<m-1<<"\n";
    return 0;
}
